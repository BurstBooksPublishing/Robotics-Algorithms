import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * Rao-Blackwellized Particle Filter for Probabilistic SLAM in Robotics.
 * Combines particle filtering with analytical integration for efficiency.
 */
public class RaoBlackwellizedParticleFilter {
    private List particles;
    private int numParticles;
    private Random random;

    public RaoBlackwellizedParticleFilter(int numParticles) {
        this.numParticles = numParticles;
        this.random = new Random();
        initializeParticles();
    }

    // Initialize particles with uniform weights and random poses
    private void initializeParticles() {
        particles = new ArrayList<>();
        for (int i = 0; i < numParticles; i++) {
            double x = random.nextDouble() * 10;  // Random x-coordinate
            double y = random.nextDouble() * 10;  // Random y-coordinate
            double theta = random.nextDouble() * 2 * Math.PI;  // Random orientation
            particles.add(new Particle(x, y, theta, 1.0 / numParticles));
        }
    }

    // Update particle weights based on sensor measurements
    public void updateWeights(double[] measurements, double[][] map) {
        double sumWeights = 0.0;
        for (Particle p : particles) {
            double likelihood = computeLikelihood(measurements, p, map);
            p.weight *= likelihood;
            sumWeights += p.weight;
        }
        // Normalize weights
        for (Particle p : particles) {
            p.weight /= sumWeights;
        }
    }

    // Compute likelihood of measurements given particle pose and map
    private double computeLikelihood(double[] measurements, Particle p, double[][] map) {
        double likelihood = 1.0;
        for (int i = 0; i < measurements.length; i++) {
            double expectedDist = expectedDistance(p, i, map);
            double diff = measurements[i] - expectedDist;
            likelihood *= Math.exp(-0.5 * diff * diff);  // Gaussian noise model
        }
        return likelihood;
    }

    // Resample particles based on their weights
    public void resample() {
        List newParticles = new ArrayList<>();
        double[] cumulativeWeights = new double[numParticles];
        cumulativeWeights[0] = particles.get(0).weight;
        for (int i = 1; i < numParticles; i++) {
            cumulativeWeights[i] = cumulativeWeights[i - 1] + particles.get(i).weight;
        }
        for (int i = 0; i < numParticles; i++) {
            double r = random.nextDouble();
            int idx = binarySearch(cumulativeWeights, r);
            newParticles.add(new Particle(particles.get(idx)));
        }
        particles = newParticles;
    }

    // Binary search for efficient resampling
    private int binarySearch(double[] arr, double value) {
        int low = 0, high = arr.length - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    // Particle class representing robot pose and weight
    private static class Particle {
        double x, y, theta;  // Pose
        double weight;       // Importance weight

        public Particle(double x, double y, double theta, double weight) {
            this.x = x;
            this.y = y;
            this.theta = theta;
            this.weight = weight;
        }

        // Copy constructor
        public Particle(Particle other) {
            this.x = other.x;
            this.y = other.y;
            this.theta = other.theta;
            this.weight = other.weight;
        }
    }
}