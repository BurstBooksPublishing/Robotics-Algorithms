import java.util.*;

/**
 * Advanced path planning for UAV swarms using A* algorithm with swarm coordination.
 * Assumes a 3D grid environment with obstacles and multiple UAVs.
 */
public class UAVSwarmPathPlanner {
    private static final int[][] DIRECTIONS = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}};
    private int[][][] grid; // 3D grid: 0=free, 1=obstacle
    private int gridSizeX, gridSizeY, gridSizeZ;
    private List swarm;

    public UAVSwarmPathPlanner(int[][][] grid, List swarm) {
        this.grid = grid;
        this.gridSizeX = grid.length;
        this.gridSizeY = grid[0].length;
        this.gridSizeZ = grid[0][0].length;
        this.swarm = swarm;
    }

    /**
     * A* path planning for a single UAV with swarm collision avoidance
     */
    public List findPath(UAV uav, int[] target) {
        PriorityQueue openSet = new PriorityQueue<>(Comparator.comparingInt(n -> n.fCost));
        Map allNodes = new HashMap<>();
        
        // Initialize start node
        Node start = new Node(uav.position, 0, heuristic(uav.position, target), null);
        openSet.add(start);
        allNodes.put(Arrays.toString(uav.position), start);

        while (!openSet.isEmpty()) {
            Node current = openSet.poll();
            
            // Check if reached target
            if (Arrays.equals(current.position, target)) {
                return reconstructPath(current);
            }

            // Explore neighbors
            for (int[] dir : DIRECTIONS) {
                int[] neighborPos = {
                    current.position[0] + dir[0],
                    current.position[1] + dir[1],
                    current.position[2] + dir[2]
                };

                // Check bounds and obstacles
                if (!isValidPosition(neighborPos) || grid[neighborPos[0]][neighborPos[1]][neighborPos[2]] == 1) {
                    continue;
                }

                // Check for other UAV positions (dynamic obstacles)
                if (isPositionOccupied(neighborPos, uav.id)) {
                    continue;
                }

                int newGCost = current.gCost + 1;
                Node neighbor = allNodes.getOrDefault(Arrays.toString(neighborPos),
                        new Node(neighborPos, Integer.MAX_VALUE, Integer.MAX_VALUE, null));
                
                if (newGCost < neighbor.gCost) {
                    neighbor.gCost = newGCost;
                    neighbor.hCost = heuristic(neighborPos, target);
                    neighbor.parent = current;
                    openSet.add(neighbor);
                    allNodes.put(Arrays.toString(neighborPos), neighbor);
                }
            }
        }
        return Collections.emptyList(); // No path found
    }

    private boolean isValidPosition(int[] pos) {
        return pos[0] >= 0 && pos[0] < gridSizeX &&
               pos[1] >= 0 && pos[1] < gridSizeY &&
               pos[2] >= 0 && pos[2] < gridSizeZ;
    }

    private boolean isPositionOccupied(int[] pos, int currentUAVId) {
        for (UAV uav : swarm) {
            if (uav.id != currentUAVId && Arrays.equals(uav.position, pos)) {
                return true;
            }
        }
        return false;
    }

    private int heuristic(int[] a, int[] b) {
        // Manhattan distance for 3D
        return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]) + Math.abs(a[2] - b[2]);
    }

    private List reconstructPath(Node endNode) {
        List path = new ArrayList<>();
        Node current = endNode;
        while (current != null) {
            path.add(0, current.position);
            current = current.parent;
        }
        return path;
    }

    private static class Node {
        int[] position;
        int gCost; // Distance from start
        int hCost; // Heuristic to target
        int fCost() { return gCost + hCost; }
        Node parent;

        public Node(int[] position, int gCost, int hCost, Node parent) {
            this.position = position;
            this.gCost = gCost;
            this.hCost = hCost;
            this.parent = parent;
        }
    }

    public static class UAV {
        int id;
        int[] position;
        
        public UAV(int id, int[] position) {
            this.id = id;
            this.position = position;
        }
    }
}