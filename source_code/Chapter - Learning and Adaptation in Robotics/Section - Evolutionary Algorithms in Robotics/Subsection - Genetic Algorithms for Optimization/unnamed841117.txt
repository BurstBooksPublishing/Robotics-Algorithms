import numpy as np
from typing import List, Tuple, Callable

class GeneticAlgorithm:
    """Genetic Algorithm for optimization in robotics (e.g., path planning or controller tuning)."""
    
    def __init__(
        self,
        population_size: int,
        chromosome_length: int,
        fitness_func: Callable[[np.ndarray], float],
        crossover_rate: float = 0.8,
        mutation_rate: float = 0.1,
        elitism_ratio: float = 0.1
    ):
        self.population_size = population_size
        self.chromosome_length = chromosome_length
        self.fitness_func = fitness_func
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_ratio = elitism_ratio

    def initialize_population(self) -> np.ndarray:
        """Initialize random population of binary chromosomes."""
        return np.random.randint(2, size=(self.population_size, self.chromosome_length))

    def select_parents(self, population: np.ndarray, fitness: np.ndarray) -> np.ndarray:
        """Select parents using tournament selection."""
        parents = []
        for _ in range(self.population_size):
            # Tournament size of 2
            candidates = np.random.choice(len(population), 2, replace=False)
            winner = candidates[np.argmax(fitness[candidates])]
            parents.append(population[winner])
        return np.array(parents)

    def crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Single-point crossover between two parents."""
        if np.random.rand() < self.crossover_rate:
            crossover_point = np.random.randint(1, self.chromosome_length)
            child1 = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))
            child2 = np.concatenate((parent2[:crossover_point], parent1[crossover_point:]))
            return child1, child2
        return parent1.copy(), parent2.copy()

    def mutate(self, chromosome: np.ndarray) -> np.ndarray:
        """Flip bits based on mutation probability."""
        mutations = np.random.rand(self.chromosome_length) < self.mutation_rate
        chromosome[mutations] = 1 - chromosome[mutations]
        return chromosome

    def evolve(self, population: np.ndarray) -> np.ndarray:
        """Perform one generation of evolution."""
        # Evaluate fitness
        fitness = np.array([self.fitness_func(ind) for ind in population])
        
        # Elitism: preserve top individuals
        elite_size = int(self.population_size * self.elitism_ratio)
        elite_indices = np.argsort(fitness)[-elite_size:]
        new_population = [population[i] for i in elite_indices]
        
        # Selection and reproduction
        parents = self.select_parents(population, fitness)
        for i in range(0, self.population_size - elite_size, 2):
            parent1, parent2 = parents[i], parents[i+1]
            child1, child2 = self.crossover(parent1, parent2)
            new_population.extend([self.mutate(child1), self.mutate(child2)])
        
        return np.array(new_population)[:self.population_size]

# Example usage for robotic path planning optimization
if __name__ == "__main__":
    # Mock fitness function (e.g., evaluates path smoothness and length)
    def fitness_func(chromosome: np.ndarray) -> float:
        # Higher fitness for more 1s (simplified example)
        return np.sum(chromosome) / len(chromosome)
    
    ga = GeneticAlgorithm(
        population_size=50,
        chromosome_length=20,
        fitness_func=fitness_func
    )
    
    population = ga.initialize_population()
    for generation in range(100):
        population = ga.evolve(population)
        best_fitness = max([fitness_func(ind) for ind in population])
        print(f"Generation {generation}: Best Fitness = {best_fitness:.3f}")