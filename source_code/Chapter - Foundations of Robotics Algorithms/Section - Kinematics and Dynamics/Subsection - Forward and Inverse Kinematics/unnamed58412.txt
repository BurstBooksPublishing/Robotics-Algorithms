import numpy as np
from scipy.optimize import minimize

class RobotArm2D:
    """A 2-DOF robotic arm for forward and inverse kinematics."""
    
    def __init__(self, l1=1.0, l2=1.0):
        """Initialize arm with link lengths l1 and l2."""
        self.l1 = l1
        self.l2 = l2
    
    def forward_kinematics(self, theta1, theta2):
        """Compute end-effector position (x, y) from joint angles."""
        x = self.l1 * np.cos(theta1) + self.l2 * np.cos(theta1 + theta2)
        y = self.l1 * np.sin(theta1) + self.l2 * np.sin(theta1 + theta2)
        return np.array([x, y])
    
    def inverse_kinematics(self, target_pos, initial_guess=(0, 0)):
        """Compute joint angles (theta1, theta2) for target (x, y) using optimization."""
        def error_fn(thetas):
            """Objective function: Euclidean distance to target."""
            current_pos = self.forward_kinematics(*thetas)
            return np.linalg.norm(current_pos - target_pos)
        
        # Constrain angles to [-2π, 2π] for numerical stability
        bounds = [(-2*np.pi, 2*np.pi), (-2*np.pi, 2*np.pi)]
        result = minimize(error_fn, initial_guess, bounds=bounds, method='L-BFGS-B')
        return result.x if result.success else None

# Example usage
if __name__ == "__main__":
    arm = RobotArm2D(l1=1.5, l2=1.0)
    
    # Forward kinematics example
    theta1, theta2 = np.pi/4, np.pi/6  # 45° and 30°
    end_effector = arm.forward_kinematics(theta1, theta2)
    print(f"End effector position: {end_effector}")
    
    # Inverse kinematics example
    target = np.array([1.8, 1.2])
    solved_angles = arm.inverse_kinematics(target)
    if solved_angles is not None:
        print(f"Solved joint angles (rad): {solved_angles}")