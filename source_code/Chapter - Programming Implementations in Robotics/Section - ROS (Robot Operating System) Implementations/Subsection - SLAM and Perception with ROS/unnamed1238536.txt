#!/usr/bin/env python3
import rospy
from nav_msgs.msg import OccupancyGrid, Odometry
from sensor_msgs.msg import LaserScan
import numpy as np

class SLAMNode:
    def __init__(self):
        rospy.init_node('slam_node', anonymous=True)
        
        # Initialize map parameters
        self.map_resolution = 0.05  # meters/pixel
        self.map_width = 200        # pixels
        self.map_height = 200       # pixels
        self.map_origin_x = -5.0    # meters
        self.map_origin_y = -5.0    # meters
        
        # Create an empty occupancy grid
        self.map_data = np.ones((self.map_height, self.map_width), dtype=np.int8) * -1  # -1: unknown
        
        # ROS subscribers and publishers
        self.laser_sub = rospy.Subscriber('/scan', LaserScan, self.laser_callback)
        self.odom_sub = rospy.Subscriber('/odom', Odometry, self.odom_callback)
        self.map_pub = rospy.Publisher('/map', OccupancyGrid, queue_size=10)
        
        # Current robot pose
        self.robot_x = 0.0
        self.robot_y = 0.0
        self.robot_yaw = 0.0

    def odom_callback(self, msg):
        """Update robot pose from odometry data"""
        self.robot_x = msg.pose.pose.position.x
        self.robot_y = msg.pose.pose.position.y
        # Convert quaternion to yaw
        q = msg.pose.pose.orientation
        self.robot_yaw = np.arctan2(2.0*(q.w*q.z + q.x*q.y), 1.0 - 2.0*(q.y*q.y + q.z*q.z))

    def laser_callback(self, msg):
        """Process laser scan data and update occupancy grid"""
        # Convert laser scan to Cartesian coordinates in robot frame
        angles = np.arange(msg.angle_min, msg.angle_max, msg.angle_increment)
        ranges = np.array(msg.ranges)
        valid = np.logical_and(ranges > msg.range_min, ranges < msg.range_max)
        
        # Convert to map coordinates
        x_robot = ranges[valid] * np.cos(angles[valid] + self.robot_yaw) + self.robot_x
        y_robot = ranges[valid] * np.sin(angles[valid] + self.robot_yaw) + self.robot_y
        
        # Convert to map grid coordinates
        x_map = ((x_robot - self.map_origin_x) / self.map_resolution).astype(int)
        y_map = ((y_robot - self.map_origin_y) / self.map_resolution).astype(int)
        
        # Update occupancy grid (simple binary update for demo)
        for x, y in zip(x_map, y_map):
            if 0 <= x < self.map_width and 0 <= y < self.map_height:
                self.map_data[y, x] = 100  # 100: occupied
        
        # Publish the updated map
        self.publish_map()

    def publish_map(self):
        """Publish the occupancy grid map"""
        map_msg = OccupancyGrid()
        map_msg.header.stamp = rospy.Time.now()
        map_msg.header.frame_id = "map"
        map_msg.info.resolution = self.map_resolution
        map_msg.info.width = self.map_width
        map_msg.info.height = self.map_height
        map_msg.info.origin.position.x = self.map_origin_x
        map_msg.info.origin.position.y = self.map_origin_y
        map_msg.data = self.map_data.flatten().tolist()
        self.map_pub.publish(map_msg)

if __name__ == '__main__':
    try:
        slam_node = SLAMNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass