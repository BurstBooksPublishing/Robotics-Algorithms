import numpy as np
import cv2
from scipy.spatial.transform import Rotation as R

class SLAMVisualOdometry:
    def __init__(self, camera_matrix, dist_coeffs=None):
        """Initialize SLAM-based visual odometry with camera parameters."""
        self.camera_matrix = camera_matrix
        self.dist_coeffs = dist_coeffs if dist_coeffs is not None else np.zeros(5)
        self.orb = cv2.ORB_create(nfeatures=2000)  # Feature detector
        self.bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)  # Feature matcher
        self.prev_frame = None
        self.prev_kp = None
        self.prev_des = None
        self.pose = np.eye(4)  # Initial pose (identity matrix)

    def process_frame(self, frame):
        """Process a frame to estimate camera motion."""
        # Undistort frame
        undistorted = cv2.undistort(frame, self.camera_matrix, self.dist_coeffs)
        
        # Detect and compute ORB features
        kp, des = self.orb.detectAndCompute(undistorted, None)
        
        if self.prev_frame is not None and self.prev_kp is not None:
            # Match features between current and previous frame
            matches = self.bf.match(self.prev_des, des)
            matches = sorted(matches, key=lambda x: x.distance)[:100]  # Top 100 matches
            
            # Extract matched points
            prev_pts = np.float32([self.prev_kp[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
            curr_pts = np.float32([kp[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
            
            # Estimate essential matrix and recover pose
            E, mask = cv2.findEssentialMat(
                prev_pts, curr_pts, self.camera_matrix, method=cv2.RANSAC, prob=0.999, threshold=1.0
            )
            _, R, t, mask = cv2.recoverPose(E, prev_pts, curr_pts, self.camera_matrix)
            
            # Update pose
            self.pose[:3, :3] = self.pose[:3, :3] @ R
            self.pose[:3, 3] += (self.pose[:3, :3] @ t).flatten()
            
        # Update previous frame data
        self.prev_frame = undistorted
        self.prev_kp = kp
        self.prev_des = des
        
        return self.pose

    def get_euler_angles(self):
        """Convert rotation matrix to Euler angles for visualization."""
        rot_matrix = self.pose[:3, :3]
        return R.from_matrix(rot_matrix).as_euler('xyz', degrees=True)