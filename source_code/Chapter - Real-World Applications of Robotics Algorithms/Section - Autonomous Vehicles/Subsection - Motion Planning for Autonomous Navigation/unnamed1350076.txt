import java.util.*;

/**
 * A* algorithm implementation for motion planning in autonomous navigation.
 * Assumes a grid-based environment with obstacles.
 */
public class MotionPlanner {
    private static class Node {
        int x, y;           // Grid coordinates
        double gCost;       // Cost from start to current node
        double hCost;       // Heuristic cost to goal
        Node parent;        // Parent node for path reconstruction

        Node(int x, int y) {
            this.x = x;
            this.y = y;
        }

        double fCost() { return gCost + hCost; }
    }

    // Heuristic function (Euclidean distance)
    private double heuristic(Node a, Node b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    /**
     * A* pathfinding algorithm for autonomous navigation
     * @param grid 2D grid with obstacles (true = blocked)
     * @param start Starting position
     * @param goal Target position
     * @return List of nodes representing the optimal path
     */
    public List aStar(boolean[][] grid, Node start, Node goal) {
        PriorityQueue openSet = new PriorityQueue<>(
            Comparator.comparingDouble(Node::fCost)
        );
        Set closedSet = new HashSet<>();
        Map openMap = new HashMap<>(); // For quick lookup

        start.gCost = 0;
        start.hCost = heuristic(start, goal);
        openSet.add(start);
        openMap.put(start.x + "," + start.y, start);

        // Possible movement directions (8-connected grid)
        int[][] directions = {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, 
                             {0,1}, {1,-1}, {1,0}, {1,1}};

        while (!openSet.isEmpty()) {
            Node current = openSet.poll();
            openMap.remove(current.x + "," + current.y);

            // Path found
            if (current.x == goal.x && current.y == goal.y) {
                return reconstructPath(current);
            }

            closedSet.add(current);

            // Explore neighbors
            for (int[] dir : directions) {
                int nx = current.x + dir[0];
                int ny = current.y + dir[1];

                // Check bounds and obstacles
                if (nx < 0 || nx >= grid.length || ny < 0 || ny >= grid[0].length 
                    || grid[nx][ny]) {
                    continue;
                }

                Node neighbor = new Node(nx, ny);
                if (closedSet.contains(neighbor)) continue;

                // Diagonal movement cost is sqrt(2), straight is 1
                double moveCost = (Math.abs(dir[0]) + Math.abs(dir[1])) == 2 ? 
                    Math.sqrt(2) : 1;
                double tentativeGCost = current.gCost + moveCost;

                // Check if neighbor is in open set
                Node openNode = openMap.get(nx + "," + ny);
                if (openNode == null || tentativeGCost < openNode.gCost) {
                    neighbor.gCost = tentativeGCost;
                    neighbor.hCost = heuristic(neighbor, goal);
                    neighbor.parent = current;

                    if (openNode == null) {
                        openSet.add(neighbor);
                        openMap.put(nx + "," + ny, neighbor);
                    }
                }
            }
        }
        return Collections.emptyList(); // No path found
    }

    // Reconstruct path from goal to start
    private List reconstructPath(Node node) {
        LinkedList path = new LinkedList<>();
        while (node != null) {
            path.addFirst(node);
            node = node.parent;
        }
        return path;
    }
}